<!DOCTYPE html><html lang="en"><head><title>Lazy load components in React | Artem Demo</title><link rel="icon" type="image/x-icon" href="/./assets/favicon-dec32dcbac.ico"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="description" content="Blog about web development, indie GameDev"><meta property="og:title" content="Lazy load components in React"><meta property="og:description" content="Blog about web development, indie GameDev"><link rel="stylesheet" href="/./assets/code-theme-b13f04ca24.css"><link rel="stylesheet" href="/./assets/site.render-0af6967fec.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-3BCNZ31TWL"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3BCNZ31TWL');</script></head><body><div><div class="header-wrapper"><div class="container"><div class="header-container"><div class="header-item header-item__logo"><a class="header-logo-link" href="/">Artem Demo &lt;/&gt;</a></div><div class="header-item header-item__menu"><div class="header-item-menu"><div class="top-menu"><div class="top-menu_item top-menu_item__active"><a class="top-menu_link" href="/">Blog</a></div><div class="top-menu_item"><a class="top-menu_link" href="/about/">About</a></div><div class="top-menu_item"><a class="top-menu_link" href="/contact/">Contact me</a></div></div></div></div></div><div class="header-separator"></div></div></div><div class="container"><div class="ContentWrapper"><h1>Lazy load components in React</h1><div class="secondary-text">25 November, 2018</div><div class="post-tags"><div class="secondary-text">Tags: <a class="post-tags-item" href="/blog/tag/react/">react</a><a class="post-tags-item" href="/blog/tag/lazy-load/">lazy-load</a><a class="post-tags-item" href="/blog/tag/React.lazy/">React.lazy</a><a class="post-tags-item" href="/blog/tag/React.Suspense/">React.Suspense</a></div></div><p>Lazy loading in React was always possible. It wasn&#x27;t so clear how to do it properly and how to handle all edge cases, as well as how to find all of them, because, like many things in life, we need first to encounter the problems, and only then can we be ready to handle them properly.</p><p>Since React version 16.6 we have had <code class="inline-code">React.lazy</code> and <code class="inline-code">React.Suspense</code> - helper function and helper component that have come to the rescue, and which promise to make it easier to deal with the lazy load. But first, let&#x27;s see what is the problem with asynchronous load and how it was handled &quot;the old way&quot;. It will help us better understand what new features React are bringing to the table.</p><p>In general asynchronous loading of a script is handled not by React (or any other library), but by webpack (I&#x27;m assuming we are using it, as our main task manager). In order to load some code we need to use dynamic <code class="inline-code">import()</code> which will return a promise and as soon as the code is loaded, it will be resolved. Something like this:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-keyword">import</span>(&#x27;./examples/some-script).<span class="hljs-title function_">then</span>((e) =&gt; {
    e.<span class="hljs-title function_">someFunction</span>();
});
</span></code></pre><p>Webpack will handle all the loading process, we don&#x27;t need to worry about it. We only need to write the code. There is no difference in the case of React, we still will need to use <code class="inline-code">import()</code>, but this time we&#x27;ll wrap it in the component.</p><p>The main catch in this process is where to place <code class="inline-code">import()</code>. This method can&#x27;t be generalized and encapsulated inside some component, like this:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Components</span> {
  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> { pathToScropt } = props;
    <span class="hljs-keyword">import</span>(pathToScropt).<span class="hljs-title function_">then</span>((component) =&gt; {
      <span class="hljs-comment">// what to do with loaded component</span>
    });
  }
  <span class="hljs-comment">// ...code</span>
}
</span></code></pre><p><code class="inline-code">import()</code> should be written with the exact path to the component (or, at least to the directory) otherwise, it won&#x27;t work. This is exactly the case with the new features as well.</p><p>However, we still want to write a wrapper, because there are additional general issues with asynchronous components that I want to solve in one place. Such as, what should be rendered in place of a component that has been loaded. I want to use some general loader in most cases and have the option to change it sometimes. For this reason, by the way, we have <code class="inline-code">React.Suspense</code> component.</p><p>Therefore the solution could be something like this:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> &#x27;react&#x27;;

<span class="hljs-keyword">const</span> lazify = (loader) =&gt; (props) =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(loader);

  <span class="hljs-keyword">const</span> loadingFallback = (() =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">React</span>.<span class="hljs-property">Children</span>.<span class="hljs-title function_">count</span>(props.<span class="hljs-property">children</span>) &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> props.<span class="hljs-property">children</span>;
    }
    <span class="hljs-keyword">return</span> &lt;span&gt;<span class="hljs-title class_">Loading</span>...&lt;/span&gt;;
  })();

  <span class="hljs-keyword">return</span> (
    &lt;<span class="hljs-title class_">React</span>.<span class="hljs-property">Suspense</span> fallback={loadingFallback}&gt;
      &lt;<span class="hljs-title class_">Component</span> {...props} /&gt;
    &lt;/<span class="hljs-title class_">React</span>.<span class="hljs-property">Suspense</span>&gt;
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> lazify;
</span></code></pre><p>And the usage:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-comment">// SomeComponent.async.jsx</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">lazify</span>(() =&gt;
  <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;SomeComponent&quot; */</span> &#x27;./<span class="hljs-title class_">SomeComponent</span>)
);
</span></code></pre><p>I&#x27;m using magic comment <code class="inline-code">/* webpackChunkName: &quot;SomeComponent&quot; */</code> in order to hint to the webpack what name to use for the chunk it will create. This name will be used in development only and it will make it much easier to keep track of the files that will be created.</p><p>In my implementation, I also use a general loading message as well as give the option to override it. If the user uses the component &quot;as is&quot;, then it will be rendered &quot;Loading…&quot; until the component is ready. If you want to render something else, you should provide children to the component and they will be rendered until the component is ready:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> &#x27;react&#x27;;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">SomeComponent</span> <span class="hljs-keyword">from</span> &#x27;./<span class="hljs-title class_">SomeComponent</span>.<span class="hljs-property">async</span>&#x27;;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RootComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      &lt;<span class="hljs-title class_">SomeComponent</span>&gt;
        &lt;span&gt;<span class="hljs-title class_">Another</span> loading…&lt;/span&gt;
      &lt;/<span class="hljs-title class_">SomeComponent</span>&gt;
    );
  }
}
</span></code></pre><p>And this is it. You can now write and use lazy components.</p></div></div></div></body></html>