<!DOCTYPE html><html lang="en"><head><title>Bridging AI with Existing Tech (With MCP, Maybe) | Artem Demo</title><link rel="icon" type="image/x-icon" href="/./assets/favicon-dec32dcbac.ico"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="description" content="Bridge AI with your tools using MCP. Learn when you need it—and when simple file-based setup is enough."><meta property="og:title" content="Bridging AI with Existing Tech (With MCP, Maybe)"><meta property="og:description" content="Bridge AI with your tools using MCP. Learn when you need it—and when simple file-based setup is enough."><link rel="stylesheet" href="/./assets/code-theme-b13f04ca24.css"><link rel="stylesheet" href="/./assets/site.render-0af6967fec.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-3BCNZ31TWL"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3BCNZ31TWL');</script></head><body><link rel="preload" as="image" href="./bridging-ai-and-everyday-apps.png"><div><div class="header-wrapper"><div class="container"><div class="header-container"><div class="header-item header-item__logo"><a class="header-logo-link" href="/">Artem Demo &lt;/&gt;</a></div><div class="header-item header-item__menu"><div class="header-item-menu"><div class="top-menu"><div class="top-menu_item top-menu_item__active"><a class="top-menu_link" href="/">Blog</a></div><div class="top-menu_item"><a class="top-menu_link" href="/about/">About</a></div><div class="top-menu_item"><a class="top-menu_link" href="/contact/">Contact me</a></div></div></div></div></div><div class="header-separator"></div></div></div><div class="container"><div class="ContentWrapper"><h1>Bridging AI with Existing Tech (With MCP, Maybe)</h1><div class="secondary-text">17 April, 2025</div><div class="post-tags"><div class="secondary-text">Tags: <a class="post-tags-item" href="/blog/tag/generative-ai/">generative-ai</a><a class="post-tags-item" href="/blog/tag/mcp/">mcp</a></div></div><img src="./bridging-ai-and-everyday-apps.png"><h2>With MCP</h2><p>MCP is a very cool piece of tech. The idea of an API for AI opens up a whole new field of possibilities. Right now, it still feels a bit detached from our day-to-day work—but we’re definitely looking for ways to bridge that gap.</p><p>Across the industry, everyone is searching for ways to integrate AI into their existing workflows. It’s clear there’s no going back.</p><p>So what does MCP actually do? It offers a protocol for communication between an AI client and a &quot;server.&quot; This &quot;server&quot; doesn’t have to live in the cloud—it can run locally on the same machine as the client. No problem there.</p><p>Let’s break down what we mean by &quot;client&quot; and &quot;server&quot; with a simple example.</p><p>A &quot;server&quot; is any service you want to expose to your AI system. Right now, it mostly works well with one category of systems—Agents. But I’ll touch on that more later. Your service doesn’t have to involve AI at all. It could be:</p><ul><li>A weather tracking service</li><li>A stock market tracker</li><li>A personal finance app</li></ul><p>You’d like to plug this into your AI workflow. For example, you might want your AI agent to check tomorrow’s weather in New York, pull stock market data, or summarize your monthly expenses—without ever opening the UI of each app. That alone is convenient. But it really shines when the agent aggregates data from multiple sources with a single prompt.</p><p>So what’s the &quot;client&quot; in this scenario? Today, there aren’t many. But your IDE might be one—if it supports Agent capabilities. Think Claude or VS Code (among others). These clients can integrate with an MCP server to let agents interact with your tools.</p><p>Let’s talk about where MCP really makes sense—and where it might be overkill.</p><p>This approach is best suited for closed systems—those where the functionality isn’t visible just by reading files. For example:</p><ul><li>Local databases</li><li>Data behind an API</li><li>External hardware (e.g., a coffee machine with an API)</li></ul><p>In these cases, AI doesn’t have natural visibility. A local database is just binary data—AI can’t do much with it, unless it’s a known format like an image or video. If the data lives on a remote server, the same problem applies.</p><p>In both cases, MCP can act as a visibility layer, helping the AI understand and interact with the system.</p><p>For hardware or services triggered over the network, there’s an API to follow—and your agent needs a hand to make that happen. MCP becomes that abstraction layer, that provides a &quot;helping hand&quot;.</p><p>But again, that doesn’t mean MCP fits every use case. I say this not to downplay its importance, but to highlight that we should always choose the right tool for the job. If your system is file-based and uses plain text, you might not need MCP at all.</p><h2>Without MCP</h2><p>If your tool creates or manages plain text files, you may just need a system instructions file. This can expose project logic directly to your AI agent, allowing it to manipulate files without extra layers.</p><p>For example, a static site generator that builds from the file system may only need basic instructions for the agent to work effectively.</p><p>This can be done using <code class="inline-code">.github/copilot-instructions.md</code>, which is recognized by GitHub Copilot. The agent will use it to guide its responses. GitHub even provides <a href="https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot">best practices for writing this file</a>.</p><p>Because this file follows convention, you don’t even have to mention it in your prompt—just ask, and Copilot will know what to do (at least in VS Code; other IDEs may vary). That alone might be enough to help you move faster. And if you later decide you need more advanced integration, you can always introduce MCP—or use an off-the-shelf solution without reinventing the wheel.</p><h3>Writing Your Instructions File</h3><p>Based on my experiments, the best approach is: start rough, then use ChatGPT to refine. Here’s a simple structure you can use—adapt it to fit your project:</p><p><strong>Overview</strong></p><p>Briefly describe the project, what it does, and its goals.</p><blockquote><p>This is a static site generator written in TypeScript. It transforms <code class="inline-code">.md</code> and <code class="inline-code">.tsx</code> files into HTML, with support for custom layouts, blog previews, and file-based routing.</p></blockquote><p><strong>Project Structure</strong></p><p>Describe key folders and file types.</p><blockquote><pre><code class="hljs"><span class="hljs">/src         <span class="hljs-comment"># Core logic</span>
  /pages     <span class="hljs-comment"># Content pages (.md or .tsx)</span>
  /public    <span class="hljs-comment"># Static assets</span>
  /scripts   <span class="hljs-comment"># Build and deployment scripts</span>
</span></code></pre></blockquote><p><strong>File Types &amp; Conventions</strong></p><p>Explain how different files are used.</p><blockquote><ul><li><code class="inline-code">.md</code> files are parsed into static pages.</li><li><code class="inline-code">.tsx</code> files are React-based components.</li><li>Blog posts go in <code class="inline-code">/pages/blog/</code> and follow the <code class="inline-code">YYYY-MM-DD-title.md</code> naming pattern.</li></ul></blockquote><p><strong>Build System</strong></p><p>Describe how the app is built.</p><blockquote><ul><li>Node.js build using <code class="inline-code">esbuild</code>.</li><li>No external template engine; rendering is done in code.</li><li>Output goes to <code class="inline-code">/dist</code>, ready for GitHub Pages.</li></ul></blockquote><p><strong>Custom Features</strong></p><p>Highlight anything that’s unique.</p><blockquote><ul><li>Blog previews use <code class="inline-code">excerpt.md</code> and <code class="inline-code">thumbnail.png</code> (if present).</li><li>Routing is based on file paths.</li><li>Supports dark mode via Tailwind CSS classes.</li></ul></blockquote><p><strong>Coding Guidelines</strong></p><p>Mention preferred coding practices.</p><blockquote><ul><li>Use modern JS/TS features.</li><li>Prefer functional patterns.</li><li>Use <code class="inline-code">async/await</code> instead of raw Promises.</li></ul></blockquote><hr><p>That’s it. Sometimes all you need is clear, human-readable instructions. If your tool lives in the file system—skip the server. No need to overengineer it.</p></div></div></div></body></html>