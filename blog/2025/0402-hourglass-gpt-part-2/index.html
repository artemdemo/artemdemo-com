<!DOCTYPE html><html lang="en"><head><title>Generating hourglass animation with ChatGPT, part 2 | Artem Demo</title><link rel="icon" type="image/x-icon" href="/./assets/favicon-dec32dcbac.ico"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="description" content="A technical dive into using Gemini 2.5 to generate an hourglass animation with particle-based sand flow. We discuss prompt refinement, code manipulation, and observations on Gemini&#039;s incremental code changes."><meta property="og:title" content="Generating hourglass animation with ChatGPT, part 2"><meta property="og:description" content="A technical dive into using Gemini 2.5 to generate an hourglass animation with particle-based sand flow. We discuss prompt refinement, code manipulation, and observations on Gemini&#039;s incremental code changes."><link rel="stylesheet" href="ChatBubble-bf34df7cea.css"><link rel="stylesheet" href="/./assets/site.render-5d1535d9c3.css"><script src="script.js?hash=9d50dbb9af" type="module"></script><link rel="stylesheet" href="script.css?hash=8de7bc1371"><script async src="https://www.googletagmanager.com/gtag/js?id=G-3BCNZ31TWL"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3BCNZ31TWL');</script></head><body><link rel="preload" as="image" href="./rusty-hourglass.png"><div><div class="header-wrapper"><div class="container"><div class="header-container"><div class="header-item header-item__logo"><a class="header-logo-link" href="/">Artem Demo &lt;/&gt;</a></div><div class="header-item header-item__menu"><div class="header-item-menu"><div class="top-menu"><div class="top-menu_item top-menu_item__active"><a class="top-menu_link" href="/">Blog</a></div><div class="top-menu_item"><a class="top-menu_link" href="/about/">About</a></div><div class="top-menu_item"><a class="top-menu_link" href="/contact/">Contact me</a></div></div></div></div></div><div class="header-separator"></div></div></div><div class="container"><div class="ContentWrapper"><h1>Generating hourglass animation with ChatGPT, part 2</h1><div class="secondary-text">02 April, 2025</div><div class="secondary-text">Tags: <a class="post-tags-item" href="/blog/tag/animations/">animations</a><a class="post-tags-item" href="/blog/tag/generative-ai/">generative-ai</a></div><img src="./rusty-hourglass.png"><p>We&#x27;re diving back into the fascinating realm of LLM-powered hourglass animations. This is part two, building directly on our previous exploration: <a href="/blog/2025/0329-hourglass-gpt/">Generating hourglass animation with Chat GPT, part 1</a>. We&#x27;ll stick with the same visual design, but this time, we&#x27;re kicking off with a pre-crafted prompt, honed from our earlier research.</p><p>So, let&#x27;s push the boundaries and see how different LLMs tackle this animation challenge.</p><p>Our next stop? Gemini 2.5. The buzz online suggests it&#x27;s a serious contender, often touted as superior to its peers, which naturally piqued my interest.</p><p>My initial foray involved feeding the ChatGPT 4.0-proven prompt directly into the standard Gemini interface (Gemini 2.0). The outcome? Let&#x27;s just say it fell short, dramatically:</p><canvas id="hourglass-gemini-01"></canvas><p>The result bore little resemblance to my sketch, and the sand color was, shall we say, a creative interpretation.</p><p>Next, I ventured into <a href="https://aistudio.google.com/">&quot;Studio AI&quot;</a>, granting access to the more acclaimed Gemini 2.5 model.</p><p>Here&#x27;s what emerged from the first couple of attempts:</p><div style="display:flex;max-width:400px;margin:0 auto"><canvas id="hourglass-gemini-02"></canvas><canvas id="hourglass-gemini-03"></canvas></div><p>Notably, this was the first model that even attempted to animate the sand flow, albeit in a rudimentary fashion. ChatGPT hadn&#x27;t offered this &quot;feature&quot; without explicit prompting. While the overall animation remained rough, we&#x27;re working with what we&#x27;ve got. Let&#x27;s keep iterating and see where this leads.</p><p>At this juncture, I opted for a fresh start, tweaking the prompt slightly. The core concept remained the same, but I emphasized the sand&#x27;s behavior, stressing that it should settle at the bottom of its designated area.</p><p>Here&#x27;s a snippet of the explanatory guidance I provided:</p><div class="ChatMarking ChatMarking_prompt"><p>In an hourglass, there are two sections: the upper section and the bottom section. Sand from the upper section falls into the bottom section. The sand in the upper section forms a downward-pointing triangle that gradually shrinks. In the bottom section, the sand forms an upward-pointing triangle that grows over time.</p><p>The triangle of sand in the upper section should not be stuck to the ceiling—this isn’t how gravity works. It should remain within the upper section but be positioned near the bottom of that section.</p></div><p>This iteration yielded a significantly improved result. The timing, I&#x27;d argue, even surpassed ChatGPT&#x27;s output:</p><canvas id="hourglass-gemini-04"></canvas><p>However, the sand stream animation was still absent. Given the previous model&#x27;s capability, I aimed to replicate that here.</p><p>The refined prompt, specifically targeting the falling sand animation, looked like this:</p><div class="ChatMarking ChatMarking_prompt"><p>Implement a particle-based animation of sand flowing from the upper section to the lower section. The animation should accurately depict the sand&#x27;s movement. Specifically:</p><ul><li>Use numerous fine particles for the sand.</li><li>Introduce a degree of natural randomness to the particles&#x27; descent.</li><li>The sand accumulation in the lower section should only begin once falling particles make contact.</li><li>Particles should disappear upon impact with the lower section.&quot;</li></ul></div><p>The outcome exceeded expectations. Not only did the animation showcase a particle stream, but it also achieved a visually appealing effect, closely aligning with my request. A minor glitch—a brief &quot;flicker&quot; at the end of the filling cycle—didn&#x27;t detract from the impressive result.</p><canvas id="hourglass-gemini-05"></canvas><p>Now, let&#x27;s delve into the overall experience of code manipulation with Gemini 2.5. It proved surprisingly smooth and informative. The model efficiently delivered code changes accompanied by clear explanations. Several aspects set Gemini apart from other models I&#x27;ve tested.</p><p>Gemini&#x27;s ability to isolate and provide only the necessary code modifications is a notable feature. While this requires manual integration, it demonstrates the model&#x27;s contextual awareness.</p><p>Furthermore, Gemini employs comments to logically segment the code, enhancing navigation. This proves particularly useful when incorporating new suggestions.</p><p>However, this &quot;focused replacement&quot; approach has a caveat. Gemini occasionally reintroduces variables defined in unchanged code segments, leading to duplication errors. These are easily rectified, but nonetheless, a minor annoyance.</p><p>Overall, the result is better than I expected. But I want to mention an important issue that one needs to take into account while working with LLMs. Currently, the context window and generated code at each step are crucial for providing good results. Only the prompt doesn&#x27;t do the trick. Generated code is a crucial part of the successful result. It means that if in the end you got what you wanted—then if you smoosh all the prompts together and pass it to the same model in a new chat (new context window), you wouldn&#x27;t get the same result. This is because you&#x27;re missing a crucial part of the equation—the generated code at every step of the way.</p></div></div></div></body></html>