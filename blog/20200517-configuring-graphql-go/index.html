<!DOCTYPE html><html lang="en"><head><title>Configuring graphql-go/graphql | Artem Demo</title><link rel="icon" type="image/x-icon" href="/./assets/favicon-dec32dcbac.ico"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="description" content="Blog about web development, indie GameDev"><meta property="og:title" content="Configuring graphql-go/graphql"><meta property="og:description" content="Blog about web development, indie GameDev"><link rel="stylesheet" href="/./assets/code-theme-b13f04ca24.css"><link rel="stylesheet" href="/./assets/site.render-0af6967fec.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-3BCNZ31TWL"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3BCNZ31TWL');</script></head><body><div><div class="header-wrapper"><div class="container"><div class="header-container"><div class="header-item header-item__logo"><a class="header-logo-link" href="/">Artem Demo &lt;/&gt;</a></div><div class="header-item header-item__menu"><div class="header-item-menu"><div class="top-menu"><div class="top-menu_item top-menu_item__active"><a class="top-menu_link" href="/">Blog</a></div><div class="top-menu_item"><a class="top-menu_link" href="/about/">About</a></div><div class="top-menu_item"><a class="top-menu_link" href="/contact/">Contact me</a></div></div></div></div></div><div class="header-separator"></div></div></div><div class="container"><div class="ContentWrapper"><h1>Configuring graphql-go/graphql</h1><div class="secondary-text">17 May, 2020</div><div class="post-tags"><div class="secondary-text">Tags:Â <a class="post-tags-item" href="/blog/tag/golang/">golang</a><a class="post-tags-item" href="/blog/tag/graphql/">graphql</a><a class="post-tags-item" href="/blog/tag/graphql-go/">graphql-go</a></div></div><p>It&#x27;s not that hard to use graphql with go, but it could take some effort to find all the gotchas. Therefore let&#x27;s save some time and talk about some configuration of graphql in Golang.</p><p>In this tutorial I&#x27;ll use <a href="https://github.com/graphql-go/graphql">graphql-go/graphql</a> library, version v0.7.9</p><p>Somehow for this library there are only a few examples of schema type definitions. And almost no example of somehow sophisticated scenarios. So you&#x27;ll need to spend some time diggin the internet in order to find a solution to your case. Here I want to share some examples.</p><p>First of all you&#x27;ll need to handle routing in order to receive graphql requests:</p><pre><code class="language-go hljs"><span class="hljs"><span class="hljs-keyword">import</span> &quot;net/http&quot;

http.Handle(&quot;/graphql&quot;, services.CorsMiddleware(controllers.GraphqlHandler()))
</span></code></pre><p><code class="inline-code">CorsMiddleware</code> will do 2 things</p><ol><li>Allow CORS (or not, you can change it in your implementation)</li><li>Handle OPTIONS request of the browser</li></ol><pre><code class="language-go hljs"><span class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EnableCors</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
    Logger.Printf(&quot;Enabling CORS (%s)&quot;, r.Method)
    w.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)
    w.Header().Set(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;)
    w.Header().Set(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST,OPTIONS&quot;)
    <span class="hljs-keyword">if</span> r.Method == &quot;OPTIONS&quot; {
        w.WriteHeader(http.StatusOK)
        <span class="hljs-keyword">return</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CorsMiddleware</span><span class="hljs-params">(next http.Handler)</span></span> http.Handler {
    <span class="hljs-keyword">return</span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
        EnableCors(w, r)

        <span class="hljs-comment">// If the request method is OPTIONS,</span>
        <span class="hljs-comment">// then I don&#x27;t want to process the body or send back a response.</span>
        <span class="hljs-comment">// In this case I will not continue to the next handler.</span>
        <span class="hljs-keyword">if</span> r.Method != &quot;OPTIONS&quot; {
            next.ServeHTTP(w,r)
        }
    })
}
</span></code></pre><p>In the same service I also have handy function to response with json:</p><pre><code class="language-go hljs"><span class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResponseJson</span><span class="hljs-params">(jsonStructData <span class="hljs-keyword">interface</span>{}, w http.ResponseWriter)</span></span> <span class="hljs-type">error</span> {
    jsonResponse, err := json.Marshal(jsonStructData)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> err
    }
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    <span class="hljs-keyword">if</span> _, err := w.Write(jsonResponse); err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> err
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</span></code></pre><p>Now, the <code class="inline-code">graphqlCtrl</code> controller. Here I need to process the body from the request and deal with the query:</p><pre><code class="language-go hljs"><span class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GraphqlHandler</span><span class="hljs-params">()</span></span> http.Handler {
    <span class="hljs-keyword">return</span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
        <span class="hljs-keyword">if</span> r.Body == <span class="hljs-literal">nil</span> {
            http.Error(w, &quot;No query data&quot;, <span class="hljs-number">400</span>)
            <span class="hljs-keyword">return</span>
        }

        <span class="hljs-keyword">var</span> rBody models.GraphqlReqBody
        <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>
        err = json.NewDecoder(r.Body).Decode(&amp;rBody)
        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
            graphqlData := models.ProcessGqlQuery(rBody.Query, rBody.Variables)
            <span class="hljs-keyword">if</span> graphqlData.Errors != <span class="hljs-literal">nil</span> {
                w.WriteHeader(http.StatusBadRequest)
            }
            err = services.ResponseJson(
                graphqlData,
                w,
            )
        }

        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            services.LoggerE.Print(err.Error())
            http.Error(w, &quot;Something went wrong&quot;, http.StatusInternalServerError)
        }
    })
}
</span></code></pre><p>Now I need to deal with the query. For this specific purpose I have the <code class="inline-code">ProcessGqlQuery</code> function, but first I need to define a general struct for the graphql request body:</p><pre><code class="language-go hljs"><span class="hljs"><span class="hljs-keyword">type</span> GraphqlReqBody <span class="hljs-keyword">struct</span> {
    Query <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;query&quot;`</span>
    OperationName <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;operationName&quot;`</span>
    Variables <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>{} <span class="hljs-string">`json:&quot;variables&quot;`</span>
}
</span></code></pre><p>Now defining the start of the query processing:</p><pre><code class="language-go hljs"><span class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ProcessGqlQuery</span><span class="hljs-params">(query <span class="hljs-type">string</span>, variables <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>{})</span></span> *graphql.Result {
    retrieveTransactions := RetrieveTransactionsFromFile()

    result := graphql.Do(
        graphql.Params{
            Schema: gqlSchema(retrieveTransactions),
            RequestString: query,
            VariableValues: variables,
        },
    )
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result.Errors) &gt; <span class="hljs-number">0</span> {
        services.LoggerE.Printf(
            &quot;failed to execute graphql operation, errors: %+v&quot;,
            result.Errors,
        )
    }

    <span class="hljs-keyword">return</span> result
}
</span></code></pre><p>I will not explain here how <code class="inline-code">RetrieveTransactionsFromFile()</code> works. It&#x27;s not important for the overall example. Far more interesting to define the schema.</p><pre><code class="language-go hljs"><span class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gqlSchema</span><span class="hljs-params">(queryTransactions <span class="hljs-keyword">func</span>()</span></span> []services.Transaction) graphql.Schema {
    queryFields := graphql.Fields{
        &quot;transactions&quot;: &amp;graphql.Field{
            Type:        graphql.NewList(hqlTransactionType),
            Description: &quot;Transactions list&quot;,
            Args: graphql.FieldConfigArgument{
                &quot;accountFrom&quot;: &amp;graphql.ArgumentConfig{
                    Type: graphql.String,
                },
                &quot;accountTo&quot;: &amp;graphql.ArgumentConfig{
                    Type: graphql.String,
                },
                &quot;dateRange&quot;: &amp;graphql.ArgumentConfig{
                    Type: graphql.NewInputObject(graphql.InputObjectConfig{
                        Name: &quot;DateRangeInput&quot;,
                        Fields: graphql.InputObjectConfigFieldMap{
                            &quot;gt&quot;: &amp;graphql.InputObjectFieldConfig{
                                Type: graphql.String,
                            },
                            &quot;lt&quot;: &amp;graphql.InputObjectFieldConfig{
                                Type: graphql.String,
                            },
                        },
                    }),
                },
            },
            Resolve: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(params graphql.ResolveParams)</span></span> (<span class="hljs-keyword">interface</span>{}, <span class="hljs-type">error</span>) {
                transactions := queryTransactions()
                transactions = services.FilterByDateRange(params.Args[&quot;dateRange&quot;], transactions)
                transactions = services.FilterByFromAccount(params.Args[&quot;accountFrom&quot;], transactions)
                transactions = services.FilterByToAccount(params.Args[&quot;accountTo&quot;], transactions)
                services.Logger.Printf(&quot;After filter left %d transactions&quot;, <span class="hljs-built_in">len</span>(transactions))
                <span class="hljs-keyword">return</span> transactions, <span class="hljs-literal">nil</span>
            },
        },
    }

    schemaConfig := graphql.SchemaConfig{
        Query: graphql.NewObject(
            graphql.ObjectConfig{
                Name: &quot;Query&quot;,
                Fields: queryFields,
            },
        ),
    }
    schema, err := graphql.NewSchema(schemaConfig)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        services.LoggerE.Printf(&quot;failed to create <span class="hljs-built_in">new</span> schema, <span class="hljs-type">error</span>: %v&quot;, err)
    }
    <span class="hljs-keyword">return</span> schema
}
</span></code></pre><p>Again, filtering methods <code class="inline-code">FilterByDateRange</code>, <code class="inline-code">FilterByFromAccount</code> and <code class="inline-code">FilterByToAccount</code> are not important here. What is left to do is to define transaction type:</p><pre><code class="language-go hljs"><span class="hljs">
<span class="hljs-keyword">var</span> hqlTransactionType = graphql.NewObject(
    graphql.ObjectConfig{
        Name: &quot;Transaction&quot;,
        Fields: graphql.Fields{
            &quot;id&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
            &quot;date&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
            &quot;transactionType&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
            &quot;accountFrom&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
            &quot;amountInAccountFromCoin&quot;: &amp;graphql.Field{
                Type: graphql.Float,
            },
            &quot;accountFromCoin&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
            &quot;accountTo&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
            &quot;amountInAccountToCoin&quot;: &amp;graphql.Field{
                Type: graphql.Float,
            },
            &quot;accountToCoin&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
            &quot;amountInDefaultCoin&quot;: &amp;graphql.Field{
                Type: graphql.Float,
            },
            &quot;exchangeRate&quot;: &amp;graphql.Field{
                Type: graphql.Float,
            },
            &quot;defaultCoin&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
            &quot;tags&quot;: &amp;graphql.Field{
                Type: graphql.NewList(graphql.String),
            },
            &quot;comments&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
            &quot;category&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
            &quot;rootCategory&quot;: &amp;graphql.Field{
                Type: graphql.String,
            },
        },
    },
)
</span></code></pre></div></div></div></body></html>