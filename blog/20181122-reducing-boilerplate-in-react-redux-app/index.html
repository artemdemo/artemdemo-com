<!DOCTYPE html><html lang="en"><head><title>Reducing boilerplate in React + Redux app | Artem Demo</title><link rel="icon" type="image/x-icon" href="/./assets/favicon-dec32dcbac.ico"><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="description" content="Blog about web development, indie GameDev"><meta property="og:title" content="Reducing boilerplate in React + Redux app"><meta property="og:description" content="Blog about web development, indie GameDev"><link rel="stylesheet" href="/./assets/code-theme-36bdf5f7fe.css"><link rel="stylesheet" href="/./assets/site.render-5d1535d9c3.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-3BCNZ31TWL"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3BCNZ31TWL');</script></head><body><div><div class="header-wrapper"><div class="container"><div class="header-container"><div class="header-item header-item__logo"><a class="header-logo-link" href="/">Artem Demo &lt;/&gt;</a></div><div class="header-item header-item__menu"><div class="header-item-menu"><div class="top-menu"><div class="top-menu_item top-menu_item__active"><a class="top-menu_link" href="/">Blog</a></div><div class="top-menu_item"><a class="top-menu_link" href="/about/">About</a></div><div class="top-menu_item"><a class="top-menu_link" href="/contact/">Contact me</a></div></div></div></div></div><div class="header-separator"></div></div></div><div class="container"><div class="ContentWrapper"><h1>Reducing boilerplate in React + Redux app</h1><div class="secondary-text">22 November, 2018</div><div class="secondary-text">Tags: <a class="post-tags-item" href="/blog/tag/react/">react</a><a class="post-tags-item" href="/blog/tag/redux/">redux</a><a class="post-tags-item" href="/blog/tag/boilerplate/">boilerplate</a><a class="post-tags-item" href="/blog/tag/constants/">constants</a></div><p>First, let’s see what is the problem, then we&#x27;ll discuss possible solutions and, in the end, we&#x27;ll compare the solutions that already exist in the market. Why in this order and why not go straight to the last point? Well, first you&#x27;re more than welcome to jump right to the end and second, I just don&#x27;t think that the solution is so easy to grasp.</p><p>Anyway, as I said, let&#x27;s see how we build a React-Redux application. Usually, for each ajax call, we need 3-4 different files. Those files that hold different types of data pieces that allow us to manage the application state:</p><ul><li>constants - unique data identifiers.</li><li>actions - data transfer functions (in some cases they also make logic for async requests to the server).</li><li>reducers - functions that define how stat should be changed.</li><li>sagas - async calls (you use them if you want to keep async operations away from actions)</li></ul><p>Let&#x27;s see a simple example:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-comment">// constants.js</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ADD_TODO</span> = &#x27;<span class="hljs-variable constant_">ADD_TODO</span>&#x27;;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TODO_ADDED</span> = &#x27;<span class="hljs-variable constant_">TODO_ADDED</span>&#x27;;

<span class="hljs-comment">// actions.js</span>
<span class="hljs-keyword">const</span> addTodo = <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">ADD_TODO</span>,
    data,
  };
};

<span class="hljs-keyword">const</span> todoAdded = <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">TODO_ADDED</span>,
    data,
  };
};

<span class="hljs-comment">// reducer.js</span>
<span class="hljs-keyword">const</span> initState = {
  <span class="hljs-attr">data</span>: [],
  <span class="hljs-attr">adding</span>: <span class="hljs-literal">false</span>,
};

<span class="hljs-keyword">const</span> todoReducer = <span class="hljs-keyword">function</span> (<span class="hljs-params">state = initState, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-attr">ADD_TODO</span>:
      <span class="hljs-keyword">return</span> {
        ...state,
        <span class="hljs-attr">adding</span>: <span class="hljs-literal">true</span>,
      };
    <span class="hljs-keyword">case</span> <span class="hljs-attr">TODO_ADDED</span>:
      <span class="hljs-keyword">return</span> {
        ...state,
        <span class="hljs-attr">data</span>: action.<span class="hljs-property">data</span>,
        <span class="hljs-attr">adding</span>: <span class="hljs-literal">false</span>,
      };

    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};

<span class="hljs-comment">// saga.js</span>
<span class="hljs-keyword">function</span>* <span class="hljs-title function_">addTodoSaga</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">take</span>(<span class="hljs-variable constant_">ADD_TODO</span>);
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">yield</span> request.<span class="hljs-title function_">post</span>(&#x27;<span class="hljs-regexp">/api/</span>todo&#x27;).<span class="hljs-title function_">send</span>(data).<span class="hljs-title function_">promise</span>();
      <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>(<span class="hljs-title function_">todoAdded</span>(result.<span class="hljs-property">body</span>));
    } <span class="hljs-keyword">catch</span> (err) {}
  }
}
</span></code></pre><p>As you see - creating those 4 files is a lot of boilerplate and I am constantly thinking about how it could be reduced. First of all, constants look a little redundant. They are only unique text identifiers, why do we need to create a separate file for them? It looks like they can be part of the action itself.</p><p>We can define constants while defining an action and then use it in the reducer and in the sagas. So the goal is to define the action in this way:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> someAction = <span class="hljs-title function_">createAction</span>(&#x27;<span class="hljs-variable constant_">SOME_ACTION</span>&#x27;);
</span></code></pre><p>Then we need a way to use this action in the reducer. So it will be convenient if the created action could return a constant simply by converting it to the primitive, for example:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(someAction); <span class="hljs-comment">// will print &quot;SOME_ACTION&quot;</span>
</span></code></pre><p>It can be done by overriding toString method. The full implementation of <code class="hljs"><span class="hljs">createAction</span></code> could look like this:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-comment">// actionCreator.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createAction = (constant, actionFunc) =&gt; {
  <span class="hljs-keyword">const</span> resultFunc = (...args) =&gt; {
    <span class="hljs-keyword">if</span> (!actionFunc) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: constant,
      };
    }
    <span class="hljs-keyword">const</span> action = <span class="hljs-title function_">actionFunc</span>(...args);
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">type</span>: constant,
      ...action,
    };
  };

  resultFunc.<span class="hljs-property">toString</span> = () =&gt; constant;

  <span class="hljs-keyword">return</span> resultFunc;
};
</span></code></pre><p>Now we need to write <code class="hljs"><span class="hljs">reducerCreator</span></code>. I want to get rid of the same code structure that appears in each reducer: <code class="hljs"><span class="hljs"><span class="hljs-keyword">switch</span></span></code>, <code class="hljs"><span class="hljs"><span class="hljs-keyword">case</span></span></code>, <code class="hljs"><span class="hljs"><span class="hljs-keyword">default</span></span></code>. It&#x27;s very repetitive and it looks like we can just define the reducer with some object that will define each case and also automatically add the default state. So it will look like this:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-keyword">const</span> todoReducer = <span class="hljs-title function_">createReducer</span>(initState, {
  [addTodo]: (state) =&gt; ({
    ...state,
    <span class="hljs-attr">adding</span>: <span class="hljs-literal">true</span>,
  }),
  [todoAdded]: (state, action) =&gt; ({
    ...state,
    <span class="hljs-attr">data</span>: action.<span class="hljs-property">data</span>,
    <span class="hljs-attr">adding</span>: <span class="hljs-literal">false</span>,
  }),
});
</span></code></pre><p>The full implementation:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-comment">// reducerCreator.js</span>
<span class="hljs-keyword">import</span> _get <span class="hljs-keyword">from</span> &#x27;lodash/get&#x27;;
<span class="hljs-keyword">import</span> _isObject <span class="hljs-keyword">from</span> &#x27;lodash/isObject&#x27;;
<span class="hljs-keyword">import</span> _isArray <span class="hljs-keyword">from</span> &#x27;lodash/isArray&#x27;;
<span class="hljs-keyword">import</span> _isFunction <span class="hljs-keyword">from</span> &#x27;lodash/isFunction&#x27;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createReducer = (initState, actionsHandler) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">state = initState, action</span>) {
    <span class="hljs-keyword">const</span> type = <span class="hljs-title function_">_get</span>(action, &#x27;type&#x27;);
    <span class="hljs-keyword">if</span> (type &amp;&amp; actionsHandler.<span class="hljs-title function_">hasOwnProperty</span>(type)) {
      <span class="hljs-keyword">const</span> handler = actionsHandler[action.<span class="hljs-property">type</span>];
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">_isFunction</span>(handler)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">handler</span>(state, action);
      }
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(&#x27;action handler should be a <span class="hljs-keyword">function</span>&#x27;);
    }
    <span class="hljs-keyword">return</span> state;
  };
};
</span></code></pre><p>This is the basic idea. We&#x27;re simplifying actions and reducers and removing constants. Now we can write the whole implementation, but it&#x27;s rarely a good idea because we could introduce errors that others have already fixed.</p><p>Therefore let&#x27;s see what solutions we already have. In the official Redux documentation is a chapter that talks exactly about that - <a href="https://redux.js.org/recipes/reducingboilerplate">how to reduce boilerplate</a> in Redux. There are links to some libraries that solve it for us: redux-actions and redux-act</p><p><strong>redux-actions</strong></p><p>https://github.com/redux-utilities/redux-actions</p><p>Library creates actions with a different structure than in <a href="https://redux.js.org/basics/actions">classic Redux</a>:</p><pre><code class="language-javascript hljs"><span class="hljs">{
  <span class="hljs-attr">type</span>: &#x27;<span class="hljs-variable constant_">UPDATE_ADMIN_USER</span>&#x27;,
  <span class="hljs-attr">payload</span>: { <span class="hljs-attr">name</span>: &#x27;<span class="hljs-title class_">Foo</span>&#x27; },
  <span class="hljs-attr">meta</span>: { <span class="hljs-attr">admin</span>: <span class="hljs-literal">true</span> },
}
</span></code></pre><p>This way payload is the only place to store data for the reducer. This will make our life easier when creating an action. In the case where the action is only passing data that doesn&#x27;t have to be separated or reorganized, we could define it in a very simple way:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">createAction</span>(&#x27;<span class="hljs-variable constant_">INCREMENT</span>&#x27;);
<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// { type: &#x27;INCREMENT&#x27; }</span>
<span class="hljs-title function_">increment</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// { type: &#x27;INCREMENT&#x27;, payload: 10 }</span>
</span></code></pre><p>API for creating reducers is <code class="hljs"><span class="hljs">handleActions()</span></code> - while creating the developer should provide the constant himself. For example, we will use the same action that increments state (see above).</p><p>Then the user will need to create a reducer, that will handle it:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-keyword">const</span> reducer = <span class="hljs-title function_">handleActions</span>(
  <span class="hljs-comment">// Action handlers:</span>
  <span class="hljs-comment">//</span>
  {
    <span class="hljs-attr">INCREMENT</span>: (state, action) =&gt; ({
      <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + action.<span class="hljs-property">payload</span>,
    }),
  },
  <span class="hljs-comment">// Default state:</span>
  <span class="hljs-comment">//</span>
  { <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span> },
);
</span></code></pre><p>As you can see, the user expected to explicitly write the same constant that he used, when he created the action. The author could have done it better and stored the constant in the action function.</p><p>In addition, I don&#x27;t like the fact that the default state comes last. Shouldn&#x27;t we first define the default state and then the action handlers. I think this way the code will be more readable.</p><p><strong>redux-act</strong></p><p>https://github.com/pauldijou/redux-act</p><p>This one stores the constants in the action itself and you don&#x27;t need to explicitly write it when defining the reducer. Also, the action creator function accepts any string as a constant, which is nice:</p><pre><code class="language-javascript hljs"><span class="hljs"><span class="hljs-keyword">import</span> { createAction, createReducer } <span class="hljs-keyword">from</span> &#x27;redux-act&#x27;;

<span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">createAction</span>(&#x27;increment the state&#x27;);
<span class="hljs-keyword">const</span> decrement = <span class="hljs-title function_">createAction</span>(&#x27;decrement the state&#x27;);

<span class="hljs-keyword">const</span> counterReducer = <span class="hljs-title function_">createReducer</span>(
  {
    [increment]: (state) =&gt; state + <span class="hljs-number">1</span>,
    [decrement]: (state) =&gt; state - <span class="hljs-number">1</span>,
  },
  <span class="hljs-number">0</span>,
); <span class="hljs-comment">// &lt;-- This is the default state</span>
</span></code></pre><p>Similar to the previous library this one uses payload property to store data. In the same way, it simplifies the way that we create actions and pass data through them.</p><p>The default state again is placed last, while creating the reducer. It looks like all libraries prefer it this way.</p><p><strong>Resume</strong></p><p>Out of these 2 libraries, I prefer the first one, <a href="https://github.com/redux-utilities/redux-actions">redux-actions</a>.</p><p>Both libraries are very similar, but <code class="hljs"><span class="hljs">redux-actions</span></code> has one feature in its API design, that makes it stand out. When creating reducer, the callback function receives 2 parameters: <code class="hljs"><span class="hljs">(state, action)</span></code>, an <code class="hljs"><span class="hljs">action</span></code> is the whole action object. In the case of <code class="hljs"><span class="hljs">redux-act</span></code> reducer will receive the only <code class="hljs"><span class="hljs">payload</span></code> and not the whole object. The only <code class="hljs"><span class="hljs">payload</span></code> is not enough and I can think about use-cases when it could problematic - I prefer to have easy access to the whole data.</p></div></div></div></body></html>