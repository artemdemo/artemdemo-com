{"data":{"site":{"siteMetadata":{"title":"Artem Demo, frontend dev.","author":"Artem Demo"}},"markdownRemark":{"id":"16782840-3385-5d2e-9893-b04299875295","excerpt":"Let’s talk for a moment about logging in the FrontEnd application. Yes, we can use standard   or any other   that is available to us, but…","html":"<p>Let’s talk for a moment about logging in the FrontEnd application. Yes, we can use standard <code class=\"language-text\">console.log</code> or any other <code class=\"language-text\">console[method]</code> that is available to us, but what we really want to have is some way to have a log available, when it’s allowed and to hide the logging, when we’re not interested in it. So let’s review this.</p>\n<p>Here are the required features:</p>\n<ul>\n<li>Should be based on a standard <code class=\"language-text\">console</code> object.</li>\n<li>Should show 3 methods: <code class=\"language-text\">log</code>, <code class=\"language-text\">warn</code>, <code class=\"language-text\">error</code> - behind the scenes they should use methods from the standard <code class=\"language-text\">console</code> object.</li>\n<li>For each log message it should print the actual browser time in the format <code class=\"language-text\">&#39;MM-DD HH:mm:ss&#39;</code>.</li>\n<li>Log in browsers console should show the actual line where it was used by the user.</li>\n<li>\n<p>A user should be able to disable it:</p>\n<ul>\n<li>By setting the <code class=\"language-text\">LOGGER</code> variable in <code class=\"language-text\">localStorage</code> to <code class=\"language-text\">false</code>.</li>\n<li>It’s must be enough to check whether logging is disabled only once, at the start of the program. No need to perform it on each log.</li>\n</ul>\n</li>\n</ul>\n<p>Actually, this problem has 3 features that make it a very good candidate for a whiteboard question during the interview. These features are:</p>\n<ul>\n<li>The resultant code is short, it will not take a long time to write.</li>\n<li>It has real-world usage and is not some abstract question regarding a problem that doesn’t exist.</li>\n<li>And it addresses some language aspects that are not widely used but are very interesting and critical in certain use-cases.</li>\n</ul>\n<p>Let’s talk about these aspects.</p>\n<p>First, we need to create a separate file, that will provide the API of our library. At least it should expose 3 methods: log, warn and error. The simplest way to do it will be the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export const log = console.log.bind(window.console);\n\nexport const warn = console.warn.bind(window.console);\n\nexport const error = console.error.bind(window.console);</code></pre></div>\n<p>This approach will allow us to use methods from our library but get all the benefits of the system’s <code class=\"language-text\">console</code> object. The browser will print the line of usage in the code and not from our library. Now we need to somehow prevent logging if it is not allowed.</p>\n<p>First, let’s create a function that will check whether log can be displayed or not:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const showLog = () =&gt; {\n    const LOGGER = localStorage.getItem(&#39;LOGGER&#39;);\n    return LOGGER === &#39;true&#39;;\n};</code></pre></div>\n<p>Now we need to utilize this function. If we allow the use of logging we will pass it to our public methods. In the case where we do not allow - we will pass an empty function.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export const log = showLog() ? console.log.bind(window.console) : () =&gt; {};\n\nexport const warn = showLog() ? console.warn.bind(window.console) : () =&gt; {};\n\nexport const error = showLog() ? console.error.bind(window.console) : () =&gt; {};</code></pre></div>\n<p>Empty function is a good solution in this case since it allows us not to care about how the user will use our methods. A user doesn’t need to check whether public methods can or can’t be used.</p>\n<p>Now, the most interesting part. How to print the time on each usage. Let’s do it in reverse order. If we already have some variable that has a timestamp value, we could do it in the following way:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export const log = showLog() ? console.log.bind(window.console, getTime) : () =&gt; {};\n\nexport const warn = showLog() ? console.warn.bind(window.console, getTime) : () =&gt; {};\n\nexport const error = showLog() ? console.error.bind(window.console, getTime) : () =&gt; {};</code></pre></div>\n<p>In the example above <code class=\"language-text\">getTime</code> should provide a timestamp each time one of the methods was called. But it means that <code class=\"language-text\">getTime</code> should be some kind of function and this looks weird since <code class=\"language-text\">console[method]</code> doesn’t accept callbacks. It will try to print each variable that has been provided, and here is the hint, when we provide a function to the <code class=\"language-text\">console.log</code>, then the whole function body will be printed - it means that the built-in method <code class=\"language-text\">toString</code> has been called. What is interesting is that we can override this method:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const getTime = function() {};\ngetTime.toString = () =&gt; {\n    return `[${moment(new Date()).format(&#39;MM-DD HH:mm:ss&#39;)}]`;\n};</code></pre></div>\n<p>The whole code will look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/* eslint-disable no-console, prefer-spread */\nimport moment from &#39;moment&#39;;\n\nconst showLog = () =&gt; {\n    const LOGGER = localStorage.getItem(&#39;LOGGER&#39;);\n    return LOGGER === &#39;true&#39;;\n};\n\nconst getTime = function() {};\ngetTime.toString = () =&gt; {\n    return `[${moment(new Date()).format(&#39;MM-DD HH:mm:ss&#39;)}]`;\n};\n\nexport const log = showLog() ? console.log.bind(window.console, getTime) : () =&gt; {};\n\nexport const warn = showLog() ? console.warn.bind(window.console, getTime) : () =&gt; {};\n\nexport const error = showLog() ? console.error.bind(window.console, getTime) : () =&gt; {};</code></pre></div>","frontmatter":{"title":"Custom logger for the FrontEnd application","date":"March 03, 2019","tags":["logger","console"]}}},"pageContext":{"slug":"/20190303-custom-logger-for-the-frontend-application/","previous":{"fields":{"slug":"/20190228-coursera-digital-product-management/"},"frontmatter":{"title":"Digital Product Management - Modern Fundamentals [coursera]","tags":["coursera","product management","studying"]}},"next":null}}